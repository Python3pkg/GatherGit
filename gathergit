#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 et
"""gathergit

A description.

TODO:
 - do metadata parsing
"""

import os
import yaml
import logging
import logging.config
import collections

# Third party libs
import argparse
from sh import rsync
from git import Repo as _GitRepo
from git import refs as _GitRefs


class Helper(object):
    """
    Contains helper functions
    """

    @staticmethod
    def create_logger(program_name, config=None):
        """
        Initialize logger
        """
        if not config:
            config = {'version': 1}
        logger = logging.getLogger(program_name)
        logging.config.dictConfig(config)
        return logger

    @staticmethod
    def sorted_dict(var):
        """
        Return a sorted dict as OrderedDict
        """
        ret = collections.OrderedDict()
        for key in sorted(list(var.keys())):
            ret[key] = var[key]
        return ret


class ConfigParser(object):
    """
    Parses the configuration file directory
    """

    def __init__(self, confdir, config=None):
        self.confdir = confdir

        if not config:
            config = {'settings': {}, 'deployments': {}}
        self.config = config

        self.parse_directory()

    def parse_directory(self):
        """
        Search for YAML files in a directory and parse them
        """
        for dirname, subdirectories, files in os.walk(self.confdir):
            for file_name in files:
                file_path = '{0}/{1}'.format(dirname, file_name)
                if file_name.endswith('.yaml'):
                    with open(file_path, 'r') as stream:
                        data = yaml.load(stream)
                    if data:
                        for root, value in data.items():
                            if root == 'settings':
                                self.config[root] = value
                            elif root == 'deployments':
                                for repo, settings in value.items():
                                    if repo not in self.config[root].keys():
                                        self.config[root][repo] = settings
                                    else:
                                        self.config[root][repo].update(settings)

    def dump(self):
        """
        Return configuration
        """
        return self.config


class GitRepo(object):
    """
    Implements a Python interface to a Git(Pyton) repository
    """

    def __init__(self, path=None):
        self.path = path
        self.git = None

    def init(self):
        """
        Initializes the Git repository
        """
        if not os.path.isdir(self.path):
            os.makedirs(self.path)
            self.git = _GitRepo.init(self.path)
        else:
            self.git = _GitRepo(self.path)

    # Refs
    def update_ref(self, remote_ref, remote_name, repo_name):
        """
        Download (fetch) objects and update references
        """
        gitremote = self.get_remote(remote_name)
        gitref = None
        reporefs = self.get_refs()
        #gitreporefs = self.get_refs(raw=True)
        #already_fetched = False
        ret = {
            'update_info': None,
            'repo': repo_name,
            'url': gitremote.config_reader.get('url'),
            'old_commit': None,
            'new_commit': None,
            'ref': None,
            'updated': False
        }

        srcref = '{}/{}'.format(remote_name, remote_ref)
        if srcref not in reporefs:
            if remote_ref not in reporefs:
                ret['updated'] = True

            gitremote.fetch()
            reporefs = self.get_refs()
            self.get_refs(raw=True)
            gitref = self.get_ref(remote_ref)

            if srcref not in reporefs:
                # ref is a tag
                srcref = remote_ref
                if srcref in reporefs:
                    # it is a new tag!
                    ret['new_commit'] = gitref.commit
                    ret['ref'] = remote_ref
                    return ret

        if remote_ref not in reporefs:
            self.git.git.checkout(srcref, b=remote_ref)
            gitref = self.get_ref(remote_ref)
            ret['updated'] = True
        else:
            gitref = self.get_ref(remote_ref)

            if not isinstance(gitref, _GitRefs.tag.TagReference):
                if str(gitref.tracking_branch()) == srcref or str(gitref.tracking_branch()).endswith('/{}'.format(srcref)):
                    gitref.checkout(force=True)
                #else:
                #    gitref.set_reference(_GitRefs.symbolic.SymbolicReference(self.git, None))
                #    gitref.delete(self.git, remote_ref)
                #    return self.update_ref(remote_ref, remote_name)
            ret['old_commit'] = gitref.commit

        if not isinstance(gitref, _GitRefs.tag.TagReference):
            ret['update_info'] = gitremote.pull(remote_ref)
        ret['ref'] = remote_ref
        ret['new_commit'] = gitref.commit
        if not ret['updated']:
            ret['updated'] = ret['old_commit'] != ret['new_commit']
        return ret

    def get_refs(self, raw=False):
        """
        Return all references in a Git repository
        """
        gitrefs = []
        for gitref in self.git.refs:
            if raw:
                gitrefs.append(gitref)
            else:
                gitrefs.append(str(gitref))
        return gitrefs

    def get_ref(self, name):
        """
        Get a single GitPython object of a repo reference
        """
        refs = self.get_refs(raw=True)
        for ref in refs:
            if str(name) == str(ref):
                return ref

    def checkout(self, branch):
        """
        Ceckout references like heads (branches) and tags
        """
        gitref = self.get_ref(branch)
        if isinstance(gitref, _GitRefs.tag.TagReference):
            return self.git.git.checkout(gitref.commit)  # TODO this is only a workaround
        elif isinstance(gitref, _GitRefs.head.Head):
            return gitref.checkout(force=True)
        else:
            print(type(gitref))  # TODO
            raise

    # Remotes
    def add_remotes(self, remotes):
        """
        Add remotes to a repository
        """
        for remote_name, remote_settings in remotes.items():
            if remote_name not in self.get_remotes():
                gitremote = self.git.create_remote(remote_name, remote_settings.get('url'))  # TOOD
                self.git.git.config('--add', 'remote.{}.fetch'.format(remote_name), '+refs/tags/*:refs/tags/*')
                gitremote.fetch()

    def get_remote(self, name):
        """
        Get a Git reference object
        """
        i = 0
        for remote in self.git.remotes:
            if str(remote) == name:
                return self.git.remotes[i]
            i = i + 1

    def get_remotes(self):
        """
        Get a list of Git remotes
        """
        remotes = []
        for remote in self.git.remotes:
            remotes.append(str(remote))
        return remotes

    # Filesystem
    def set_path(self, path):
        """
        Set the repository file system path
        """
        self.path = path

    def get_path(self):
        """
        Get the repository file system path
        """
        return self.path


class Repo(dict):
    """Represents a repository/ module
    """

    def __init__(self):
        """
        Constructor initializing instance variables
        """
        dict.__init__(self)
        self['name'] = ''
        self['defaults'] = {}
        self['branches'] = {}
        self['updates'] = {}
        self['target'] = '/tmp/gitgather-deployment'
        self.git = GitRepo()

    def add_branches(self, branches, deployment_settings):
        """
        Add branches to our Repo object
        """
        for branch, _branch_settings in branches.items():
            branch_name = str(branch)
            branch_settings = _branch_settings

            # REF
            if isinstance(_branch_settings, str) or isinstance(_branch_settings, float) or isinstance(_branch_settings, int):
                branch_settings = {'ref': str(_branch_settings)}
            if not isinstance(branch_settings.get('ref'), str):
                branch_settings['ref'] = str(branch_settings['ref'])

            if branch_name not in self['branches'].keys():
                self['branches'][branch_name] = branch_settings
            else:
                self['branches'][branch_name].update(branch_settings)

            # REPO
            if 'repo' not in self['branches'][branch_name].keys():
                self['branches'][branch_name]['repo'] = self.get('defaults').get('repo', self['name'])

            # URL
            if 'url' not in self['branches'][branch_name].keys():
                url = self.get('defaults').get('url', deployment_settings.get('defaults', {}).get('url'))
                if url is None:
                    base_url = self['branches'][branch_name].get('base_url', self.get('defaults').get(
                        'base_url', deployment_settings.get('defaults', {}).get('base_url')))
                    url = '{}/{}'.format(base_url, self['branches'][branch_name]['repo'])

                self['branches'][branch_name]['url'] = url

    def sync(self, local_branch, remote_branch, root=''):
        """
        Sync/ update/ deploy a repository
        """
        src_path = '{}/{}'.format(self.git.get_path(), root)
        dst_path = '{}/{}/{}/'.format(self.get('target'), local_branch, self.get('name'))

        if not os.path.isdir(dst_path):
            os.makedirs(dst_path)
        if not src_path.endswith('/'):
            src_path += '/'
        if not dst_path.endswith('/'):
            dst_path += '/'

        self.git.checkout(remote_branch)

        print(rsync('--verbose', '--archive', '--checksum', '--delete', '--exclude=.git/', src_path, dst_path))  # TODO


class Repoindex(dict):
    """
    Maintains a list of repositories
    """

    def __init__(self):
        dict.__init__(self)

    def add_repo(self, deployment_name, repo_name, repo):
        """
        Add a repo to the index
        """
        if deployment_name not in self.keys():
            self[deployment_name] = {}
        if repo_name not in self[deployment_name].keys():
            self[deployment_name][repo_name] = self.verify_repo(repo)
        else:
            raise

    def verify_repo(self, repo):
        """
        Verify and correct the attributes of a repo object
        """
        if not repo.get('defaults').get('cache'):
            repo['defaults']['cache'] = 'common'
        return repo

    def sync_repos(self, sync_all=False):
        if sync_all:
            for deployment_name, repolist in Helper.sorted_dict(self).items():
                for repo_name, repo in Helper.sorted_dict(repolist).items():
                    #print(deployment_name, '=====>', repo.get('name'), repo.get('updates'))
                    for branch_name, branch_settings in Helper.sorted_dict(repo.get('branches')).items():
                        pass  # TODO
                        #print(branch_name, '==========>', branch_settings)
        else:
            pending_updates = []
            for deployment_name, repolist in Helper.sorted_dict(self).items():
                for repo_name, repo in Helper.sorted_dict(repolist).items():
                    if repo.get('updates').get('updated_refs'):
                        pending_updates.append(repo.get('updates'))
            if pending_updates:
                for pending_update in pending_updates:
                    cache_name = pending_update.get('cache').name

                    for updated_ref in pending_update.get('updated_refs'):
                        repo_name = updated_ref.get('repo')
                        repo_url = updated_ref.get('url')
                        repo_ref = updated_ref.get('ref')

                        for deployment_name, repolist in Helper.sorted_dict(self).items():
                            for repo_name, repo in Helper.sorted_dict(repolist).items():
                                for branch_name, branch_settings in Helper.sorted_dict(repo.get('branches')).items():
                                    if repo_url == branch_settings.get('url') and \
                                       repo_ref == branch_settings.get('ref') and \
                                       cache_name == branch_settings.get('cache', repo.get('defaults').get('cache')):
                                        repo.sync(branch_name, repo_ref, branch_settings.get('root', ''))


class Cache(object):
    """Cache representation of a repo"""

    def __init__(self, name, settings, repo=None):
        self.name = name
        self.settings = settings
        self.path = self.settings.get('path', '/tmp/gathergit-cache')
        self.repo = repo

    def init(self):
        """
        Initialize cache
        """
        if not os.path.isdir(self.path):
            os.makedirs(self.path)

    def update(self, repo):
        """
        Update the cache, e.g. the Git repository in the file system
        """
        self.repo = repo
        branches = self.repo.get('branches')
        changed_refs = []

        for branch_name, branch_settings in Helper.sorted_dict(branches).items():
            repo_path = '{}/{}'.format(self.path, branch_settings.get('repo'))
            repo['remotes'] = {'origin': {'url': branch_settings.get('url')}}

            self.repo.git.set_path(repo_path)
            self.repo.git.init()
            self.repo.git.add_remotes(repo['remotes'])

            update_info = self.repo.git.update_ref(branch_settings.get('ref'), 'origin', branch_settings.get('repo'))
            if update_info.get('updated'):
                changed_refs.append(update_info)
        return changed_refs


def main():
    version = '0.0.1'
    program_name = 'gathergit'
    parser = argparse.ArgumentParser(prog=program_name, description='A description')

    # general args
    parser.add_argument('-V', action='version', version='%(prog)s {version}'.format(version=version))
    parser.add_argument('--confdir',
                        action='store',
                        dest='confdir',
                        help='directory to search for configuration files (default: config/)',
                        default='config/')
    parser.add_argument('--all',
                        action='store_true',
                        dest='sync_all',
                        help='Initialize, update and synchronize ALL repositories',
                        default=False)

    parser_results = parser.parse_args()
    confdir = parser_results.confdir
    sync_all = parser_results.sync_all

    # config parsing
    cfg_parser = ConfigParser(confdir)
    config = cfg_parser.dump()

    # logging
    logconfig = config.get('settings', {}).get('logging', {})
    logger = Helper().create_logger(program_name, logconfig)

    # let's start working now
    logger.debug('Starting new instance of %s', program_name)
    logger.debug('Raw configuration: %s', config)

    # collecting deployment configuration
    deployments = {}
    repolists = {}
    repoindex = Repoindex()
    for deployment_name, deployment_settings in config.get('deployments', {}).items():
        repos = deployment_settings.get('repos')

        if repos is None:
            continue

        deployments[deployment_name] = {'target': deployment_settings.get('target'), 'defaults': deployment_settings.get('defaults', {})}
        if deployment_name not in repolists.keys():
            repolists[deployment_name] = {}
        repolists[deployment_name].update(repos)

    # updating caches
    for deployment_name, repolist in Helper.sorted_dict(repolists).items():
        for repoid, repo_settings in Helper.sorted_dict(repolist).items():
            repo_name = repo_settings.get('name', repoid)
            repo_defaults = repo_settings.get('defaults', {})
            branches = repo_settings.get('branches')
            if branches is None:
                logger.info('Skipping repo %s of deployment definition %s, is doesn\'t have any branches defined', repo_name,
                            deployment_name)
                continue

            # adding repo to repoindex
            repo = Repo()
            repo['name'] = repo_name
            repo['defaults'] = repo_defaults
            repo['target'] = deployments[deployment_name].get('target')
            repo.add_branches(branches, deployments[deployment_name])
            repoindex.add_repo(deployment_name, repoid, repo)

            cache_name = repoindex[deployment_name][repoid].get('defaults').get('cache')
            cache_settings = config.get('settings').get('caches').get(cache_name)
            cache = Cache(name=cache_name, settings=cache_settings)
            cache.init()
            updated_refs = cache.update(repoindex[deployment_name][repoid])

            if updated_refs:
                repoindex[deployment_name][repoid]['updates'] = {'updated_refs': updated_refs, 'cache': cache}
            elif sync_all:
                repoindex[deployment_name][repoid]['updates'] = {'cache': cache}

    repoindex.sync_repos(sync_all)

    # Everything is done, closing now
    logger.debug('Shutting down..')


if __name__ == '__main__':
    exit(main())
