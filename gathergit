#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 et
"""gathergit

A description.

TODO:
 - do metadata parsing
"""

from time import sleep
import os
import re
import ssl
import sys
import yaml
import logging
import logging.config

# Third party libs
import argparse
import pprint
from sh import rsync
from git import Repo as _GitRepo
from git import refs as _GitRefs


class Helper(object):
    @staticmethod
    def create_logger(program_name, config=None):
        if not config:
            config = {'version': 1}
        logger = logging.getLogger(program_name)
        logging.config.dictConfig(config)
        return logger

    @staticmethod
    def sorted_dict(var):
        ret = {}
        for key in sorted(list(var.keys())):
            ret[key] = var[key]
        return ret


class ConfigParser(object):
    def __init__(self, confdir, config=None):
        self.confdir = confdir

        if not config:
            config = {'settings': {}, 'deployments': {}}
        self.config = config

        self.parse_directory()

    def parse_directory(self):
        for dirname, subdirectories, files in os.walk(self.confdir):
            for file_name in files:
                file_path = '{0}/{1}'.format(dirname, file_name)
                if file_name.endswith('.yaml'):
                    with open(file_path, 'r') as stream:
                        data = yaml.load(stream)
                    if data:
                        for root, value in data.items():
                            if root == 'settings':
                                self.config[root] = value
                            elif root == 'deployments':
                                for repo, settings in value.items():
                                    if repo not in self.config[root].keys():
                                        self.config[root][repo] = settings
                                    else:
                                        self.config[root][repo].update(settings)

    def dump(self):
        return self.config


class GitRepo(object):
    def __init__(self, path=None):
        self.path = path
        self.git = None

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)
            self.git = _GitRepo.init(self.path)
        else:
            self.git = _GitRepo(self.path)

    # Refs
    def update_ref(self, remote_ref, remote_name, repo_name):
        gitremote = self.get_remote(remote_name)
        gitref = None
        reporefs = self.get_refs()
        gitreporefs = self.get_refs(raw=True)
        already_fetched = False
        ret = {'update_info': None, 'old_commit': None, 'new_commit': None, 'ref': None, 'updated': False}

        srcref = '{}/{}'.format(remote_name, remote_ref)
        if srcref not in reporefs:
            if remote_ref not in reporefs:
                ret['updated'] = True

            fetch_info = gitremote.fetch()
            reporefs = self.get_refs()
            gitreporefs = self.get_refs(raw=True)
            gitref = self.get_ref(remote_ref)

            if srcref not in reporefs:
                # ref is a tag
                srcref = remote_ref
                # is it a tag we haven't downloaded yet?
                #if srcref not in reporefs:
                #    #fetch_info = gitremote.fetch(srcref)
                #reporefs = self.get_refs()
                if srcref in reporefs:
                    # it is a new tag!
                    ret['new_commit'] = gitref.commit
                    ret['ref'] = remote_ref
                    return ret

        if remote_ref not in reporefs:
            self.git.git.checkout(srcref, b=remote_ref)
            gitref = self.get_ref(remote_ref)
            ret['updated'] = True
        else:
            gitref = self.get_ref(remote_ref)

            if not isinstance(gitref, _GitRefs.tag.TagReference):
                if str(gitref.tracking_branch()) == srcref or str(gitref.tracking_branch()).endswith('/{}'.format(srcref)):
                    gitref.checkout(force=True)
                #else:
                #    print('yaaaaarp!')
                #    gitref.set_reference(_GitRefs.symbolic.SymbolicReference(self.git, None))
                #    gitref.delete(self.git, remote_ref)
                #    return self.update_ref(remote_ref, remote_name)
            ret['old_commit'] = gitref.commit

        if not isinstance(gitref, _GitRefs.tag.TagReference):
            ret['update_info'] = gitremote.pull(remote_ref)
        ret['ref'] = remote_ref
        ret['new_commit'] = gitref.commit
        if not ret['updated']:
            ret['updated'] = ret['old_commit'] != ret['new_commit']
        return ret

    def get_refs(self, raw=False):
        gitrefs = []
        for gitref in self.git.refs:
            if raw:
                gitrefs.append(gitref)
            else:
                gitrefs.append(str(gitref))
        return gitrefs

    def get_ref(self, name):
        refs = self.get_refs(raw=True)
        for ref in refs:
            if name == str(ref):
                return ref

    def checkout(self, branch):
        gitref = self.get_ref(branch)
        return gitref.checkout(force=True)

    # Remotes
    def add_remotes(self, remotes):
        for remote_name, remote_settings in remotes.items():
            if remote_name not in self.get_remotes():
                gitremote = self.git.create_remote(remote_name, remote_settings.get('url'))  #TOOD
                self.git.git.config('--add', 'remote.{}.fetch'.format(remote_name), '+refs/tags/*:refs/tags/*')
                gitremote.fetch()

    def get_remote(self, name):
        i = 0
        for remote in self.git.remotes:
            if str(remote) == name:
                return self.git.remotes[i]
            i = i + 1

    def get_remotes(self):
        remotes = []
        for remote in self.git.remotes:
            remotes.append(str(remote))
        return remotes

    # Filesystem
    def set_path(self, path):
        self.path = path

    def get_path(self):
        return self.path


class Repo(dict):
    def __init__(self, name, branches=None, defaults=None, gitrepo=GitRepo()):
        self['name'] = name
        self['defaults'] = defaults or {}
        self['branches'] = branches or {}
        self['updates'] = {}
        self.git = gitrepo

    def add_branches(self, branches, deployment_settings):
        #if 'base_url' not in branch_defaults and 'base_url' in repo_settings.get('defaults', {}).keys():
        #    branch_defaults['base_url'] = repo_settings.get('base_url')

        for branch, _branch_settings in branches.items():
            branch_name = str(branch)
            branch_settings = _branch_settings

            # REF
            if isinstance(_branch_settings, str) or isinstance(_branch_settings, float) or isinstance(_branch_settings, int):
                branch_settings = {'ref': str(_branch_settings)}
            if not isinstance(branch_settings.get('ref'), str):
                branch_settings['ref'] = str(branch_settings['ref'])

            if branch_name not in self['branches'].keys():
                self['branches'][branch_name] = branch_settings
            else:
                self['branches'][branch_name].update(branch_settings)

            # REPO
            if 'repo' not in self['branches'][branch_name].keys():
                self['branches'][branch_name]['repo'] = self.get('defaults').get('repo', self['name'])

            # URL
            if 'url' not in self['branches'][branch_name].keys():
                url = self.get('defaults').get('url', deployment_settings.get('defaults', {}).get('url'))
                if url is None:
                    base_url = self['branches'][branch_name].get('base_url', self.get('defaults').get(
                        'base_url', deployment_settings.get('defaults', {}).get('base_url')))
                    url = '{}/{}'.format(base_url, self['branches'][branch_name]['repo'])

                self['branches'][branch_name]['url'] = url


class Repoindex(dict):
    def __init__(self, index=None):
        self = index or {}

    def add_repo(self, deployment_name, repo_name, repo):
        if deployment_name not in self.keys():
            self[deployment_name] = {}
        if repo_name not in self[deployment_name].keys():
            self[deployment_name][repo_name] = self.verify_repo_settings(repo)
        else:
            raise 'TOOD'

    def verify_repo_settings(self, repo):
        if not repo.get('defaults').get('cache'):
            repo['defaults']['cache'] = 'common'

        return repo


class Cache(object):
    """Cache representation of a repo"""

    def __init__(self, name, settings, repo=None):
        self.name = name
        self.settings = settings
        self.path = self.settings.get('path', '/tmp/gathergit-cache')
        self.repo = repo

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)

    def update(self, repo):
        self.repo = repo
        branches = self.repo.get('branches')
        changed_refs = []

        for branch_name, branch_settings in Helper.sorted_dict(branches).items():
            repo_path = '{}/{}'.format(self.path, branch_settings.get('repo'))
            repo['remotes'] = {'origin': {'url': branch_settings.get('url')}}

            self.repo.git.set_path(repo_path)
            self.repo.git.init()
            self.repo.git.add_remotes(repo['remotes'])

            update_info = self.repo.git.update_ref(branch_settings.get('ref'), 'origin', branch_settings.get('repo'))
            if update_info.get('updated'):
                changed_refs.append(update_info)
        return changed_refs


class Deployment(object):
    def __init__(self, reposet_settings):
        self.base_path = reposet_settings.get('target', '/tmp/gitgather-deployment')
        self.init()

    def init(self):
        if not os.path.isdir(self.base_path):
            os.makedirs(self.base_path)

    def update(self, repo, update_infos):
        for repo_full, repo_update_info in update_infos.items():
            local_branch, old_commit, new_commit = repo_update_info.get('update_info')
            repo.git.checkout(local_branch)
            dst_path = '{}/{}/{}/'.format(self.base_path, local_branch, repo.get('name'))
            src_path = '{}/{}'.format(repo.git.get_path(), repo.get('deploy').get(local_branch).get('root'))

            if not os.path.isdir(src_path):
                src_path = repo.git.get_path()
                if not os.path.isdir(src_path):
                    raise 'w00t!'  #TODO

            if not src_path.endswith('/'):
                src_path += '/'
            if not os.path.isdir(dst_path):
                os.makedirs(dst_path)

            print(local_branch, src_path, dst_path)
            print(rsync('--verbose', '--archive', '--checksum', '--delete', '--exclude=.git/', src_path, dst_path))


def main():
    version = '0.0.1'
    program_name = 'gathergit'
    parser = argparse.ArgumentParser(prog=program_name, description='A description')

    # general args
    parser.add_argument('-V', action='version', version='%(prog)s {version}'.format(version=version))
    parser.add_argument('--confdir',
                        action='store',
                        dest='confdir',
                        help='directory to search for configuration files (default: config/)',
                        default='config/')
    parser.add_argument('--all',
                        action='store_true',
                        dest='sync_all',
                        help='Initialize, update and synchronize ALL repositories',
                        default=False)

    parser_results = parser.parse_args()
    confdir = parser_results.confdir
    sync_all = parser_results.sync_all

    # config parsing
    cfg_parser = ConfigParser(confdir)
    config = cfg_parser.dump()

    # logging
    logconfig = config.get('settings', {}).get('logging', {})
    logger = Helper().create_logger(program_name, logconfig)

    # let's start working now
    logger.debug('Starting new instance of %s', program_name)
    logger.debug('Raw configuration: %s', config)

    cachesets = {}
    for cacheid, cache_settings in config.get('settings').get('cache').items():
        cachesets[cacheid] = Cache(name=cacheid, settings=cache_settings)

    # collecting deployment configuration
    deployments = {}
    repolists = {}
    repoindex = Repoindex()
    for deployment_name, deployment_settings in config.get('deployments', {}).items():
        repos = deployment_settings.get('repos')

        if repos is None:
            continue

        deployments[deployment_name] = {'target': deployment_settings.get('target'), 'defaults': deployment_settings.get('defaults', {})}
        if deployment_name not in repolists.keys():
            repolists[deployment_name] = {}
        repolists[deployment_name].update(repos)

    # updating caches
    update_infos = {}
    for deployment_name, repolist in Helper.sorted_dict(repolists).items():
        for repoid, repo_settings in Helper.sorted_dict(repolist).items():
            repo_name = repo_settings.get('name', repoid)
            repo_defaults = repo_settings.get('defaults', {})
            branches = repo_settings.get('branches')
            if branches is None:
                logger.info('Skipping repo %s of deployment definition %s, is doesn\'t have any branches defined', repo_name,
                            deployment_name)
                continue

            # adding repo to repoindex
            repoindex.add_repo(deployment_name, repoid, Repo(name=repo_name, defaults=repo_defaults))
            repoindex[deployment_name][repoid].add_branches(branches, deployments[deployment_name])

            cache = cachesets[repoindex[deployment_name][repoid].get('defaults').get('cache')]
            cache.init()
            updated_refs = cache.update(repoindex[deployment_name][repoid])

            if updated_refs:
                repoindex[deployment_name][repoid]['updates'] = {'updated_refs': updated_refs, 'cache': cache}
            elif sync_all:
                repoindex[deployment_name][repoid]['updates'] = {'cache': cache, 'init': True}
                #update_infos[repoid] = {deployment_name: {'updated_refs': updated_refs, 'cache': cache}}

    pprint.pprint(repoindex)
    sys.exit()
    # deploying repos, iterate over list of updates
    pending_repo_deployments = {}
    for repoid, updated_repo in Helper.sorted_dict(update_infos).items():
        # iterate over deployment definition of all updated repos
        for updated_deployment, repo_update in Helper.sorted_dict(updated_repo).items():
            # iterate over every single Git ref of a Git repo that has been updated
            for updated_ref in repo_update.get('updated_refs'):
                repo_name = updated_ref.get('repo')
                ref_name = updated_ref.get('ref')
                cache_name = repo_update.get('cache').name

                # search for repos that be updated by the updated reference above
                logger.debug('Searching for repos with upstream=%s, reference=%s and cache=%s to apply update', repo_name, ref_name,
                             cache_name)
                for deployment_name, repolist in Helper.sorted_dict(repolists).items():
                    for repo, repo_settings in Helper.sorted_dict(repolist).items():
                        # procede if both repos share the same cache
                        if cache_name == repo_settings.get('defaults').get('cache', 'common'):
                            for branch, branch_settings in Helper.sorted_dict(repo_settings.get('branches')).items():
                                branch_settings = repo_settings.get('branches')[branch]

                                match = False
                                # TODO: use Repo() as type for repos instead of config dict (to reduce if-conditionals like the following)
                                if isinstance(branch_settings, str):
                                    match = ref_name == branch_settings and repo_name == repo_settings.get('defaults').get('repo')
                                else:
                                    match = ref_name == branch_settings.get('ref') and repo_name == branch_settings.get('repo')

                                if match:
                                    logger.debug('Going to update repo=%s (upstream=%s) of deployment definition %s', repo,
                                                 repo_settings.get('defaults').get('repo'), deployment_name)
                                    #pending_repo_deployments = {
                                    #    'repo': repo_update.get('cache').repo
                                    #}

    pprint.pprint(deployments)
    pprint.pprint(repolists)
    sys.exit()

    #for update_info in update_infos:
    #    target = Target(reposet_settings)
    #    if update_info:
    #        target.update(repo, update_info)

    # Everything is done, closing now
    logger.debug('Shutting down..')


if __name__ == '__main__':
    exit(main())
