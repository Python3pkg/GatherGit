#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 et
"""gathergit

A description.
"""

from time import sleep
import os
import re
import ssl
import sys
import yaml
import logging
import logging.config

#from dulwich.repo import Repo
#from dulwich.client import TCPGitClient
#from dulwich import client as dulclient

from git import Repo as _GitRepo
from git import refs as _refs

# Third party libs
import argparse
import email.message
import pprint


def create_logger(program_name, config=None):
    if not config:
        config = {'version': 1}
    logger = logging.getLogger(program_name)
    logging.config.dictConfig(config)
    return logger


class ConfigParser(object):
    def __init__(self, confdir, config=None):
        self.confdir = confdir

        if not config:
            config = {'settings': {}, 'reposets': {}}
        self.config = config

        self.parse_directory()

    def parse_directory(self):
        for dirname, subdirectories, files in os.walk(self.confdir):
            for file_name in files:
                file_path = '{0}/{1}'.format(dirname, file_name)
                if file_name.endswith('.yaml'):
                    with open(file_path, 'r') as stream:
                        data = yaml.load(stream)
                    if data:
                        for root, value in data.items():
                            if root == 'settings':
                                self.config[root] = value
                            elif root == 'reposets':
                                for repo, settings in value.items():
                                    if repo not in self.config[root].keys():
                                        self.config[root][repo] = settings
                                    else:
                                        self.config[root][repo].update(settings)
                            #elif root == 'filters':
                            #    for account, filter_set in value.items():
                            #        for filterset_name, filterset_data in filter_set.items():
                            #            if account not in self.config[root].keys():
                            #                self.config[root][account] = {}
                            #            self.config[root][account].update({filterset_name: filterset_data})

    def dump(self):
        return self.config


class GitRepo(object):
    def __init__(self, path=None):
        self.path = path
        self.git = None

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)
            self.git = _GitRepo.init(self.path)
        else:
            self.git = _GitRepo(self.path)

    # Refs
    def update_ref(self, remote_ref, branch, remote):
        gitremote = self.get_remote(remote)
        reporefs = self.get_refs()
        gitreporefs = self.get_refs(raw=True)

        srcref = '{}/{}'.format(remote, remote_ref)
        if srcref not in reporefs:
            srcref = remote_ref

        if branch not in reporefs:
            self.git.git.checkout(srcref, b=branch)
        else:
            gitref = self.get_ref(branch)

            if str(gitref.tracking_branch()) == srcref or str(gitref.tracking_branch()).endswith('/{}'.format(srcref)):
                gitref.checkout(force=True)
            else:
                gitref.set_reference(_refs.symbolic.SymbolicReference(self.git, None))
                gitref.delete(self.git, branch)
                return self.update_ref(remote_ref, branch, remote)

            old_commit = gitref.commit
            #fetch_info = gitremote.fetch(refspec='{}'.format(remote_ref))
            info = gitremote.pull(remote_ref)

            return (info, old_commit, gitref.commit)

    def get_refs(self, raw=False):
        gitrefs = []
        for gitref in self.git.refs:
            if raw:
                gitrefs.append(gitref)
            else:
                gitrefs.append(str(gitref))
        return gitrefs

    def get_ref(self, name):
        refs = self.get_refs(raw=True)
        for ref in refs:
            if name == str(ref):
                return ref

    # Remotes
    def add_remotes(self, remotes):
        for remote in remotes:
            if remote not in self.get_remotes():
                gitremote = self.git.create_remote(remote, remotes.get(remote).get('url'))  #TOOD
                self.git.git.config('--add', 'remote.{}.fetch'.format(remote), '+refs/tags/*:refs/tags/*')
                gitremote.fetch()

    def get_remote(self, name):
        i = 0
        for remote in self.git.remotes:
            if str(remote) == name:
                return self.git.remotes[i]
            i = i + 1

    def get_remotes(self):
        remotes = []
        for remote in self.git.remotes:
            remotes.append(str(remote))
        return remotes

    # Filesystem
    def set_path(self, path):
        self.path = path

    def get_path(self):
        return self.path


class Repo(dict):
    def __init__(self, name, remotes, deploy, gitrepo=GitRepo()):
        self['name'] = name
        self['remotes'] = remotes
        self['deploy'] = deploy
        self.git = gitrepo


class Cache(object):
    def __init__(self, settings):
        self.settings = settings
        self.path = self.settings.get('path')

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)

    def update(self, repo):
        remotes = repo.get('remotes')

        repo_path = '{}/{}'.format(self.path, remotes.get(list(remotes.keys())[0]).get('repo'))  #TODO
        repo.git.set_path(repo_path)
        repo.git.init()
        repo.git.add_remotes(remotes)

        changed_versions = []
        for remote_name in remotes:
            for refalias, refid in repo.get('deploy').items():
                info, old_commit, new_commit = repo.git.update_ref(refid, refalias, remote_name)
                info = info[0]
                if new_commit != old_commit:
                    print('changed')
                    changed_versions.append((refalias, old_commit, new_commit))
        return changed_versions


def main():
    version = '0.0.1'
    program_name = 'gathergit'
    parser = argparse.ArgumentParser(prog=program_name, description='A description')

    # General args
    parser.add_argument('-V', action='version', version='%(prog)s {version}'.format(version=version))
    parser.add_argument('-t', '--test',
                        action='store_true',
                        dest='test',
                        help='Run in test mode, run read-only IMAP commands only',
                        default=None)
    parser.add_argument('--confdir',
                        action='store',
                        dest='confdir',
                        help='directory to search for configuration files (default: config/)',
                        default='config/')

    parser_results = parser.parse_args()
    confdir = parser_results.confdir
    test = parser_results.test

    # Config Parsing
    cfg_parser = ConfigParser(confdir)
    config = cfg_parser.dump()
    if test is not None:
        config['settings']['test'] = test

    # Logging
    logconfig = config.get('settings', {}).get('logging', {})
    logger = create_logger(program_name, logconfig)

    # Let's start working now
    logger.debug('Starting new instance of %s', program_name)
    logger.debug('Raw configuration: %s', config)

    #repo = Repo.init('testrepo')
    #print(repo)
    #repo.create_remote('origin', 'https://github.com/bechtoldt/mailfilter.git')
    #repo.git.config('--add', 'remote.origin.fetch', '+refs/tags/*:refs/tags/*')
    #repo.git.config('http.sslVerify', True)

    #origin = repo.remotes[0]
    #fetch_results = origin.fetch()
    #for ref in repo.refs:
    #    parted = ref.name.partition('/')
    #    rspec = parted[2] if parted[2] else parted[0]
    #    print(ref, parted, rspec)
    #repo.git.checkout('master')

    caches = {}
    for cacheid, cache_settings in config.get('settings').get('cache').items():
        caches[cacheid] = Cache(settings=cache_settings)

    for reposetid, reposet_settings in config.get('reposets').items():
        target = reposet_settings.get('target', None)
        cache = caches[reposet_settings.get('cache', 'common')]
        cache.init()

        for repoid, repo_settings in reposet_settings.get('repos').items():
            remotes = repo_settings.get('remotes', None)
            if not remotes:
                remotes = {
                    'origin': {
                        'url': repo_settings.get('url', '{}/{}'.format(reposet_settings.get('defaults').get('base_url'),
                                                                       repo_settings.get('repo'))),
                        'repo': repo_settings.get('repo'),
                    }
                }

            repo = Repo(name=repo_settings.get('name', repoid), remotes=remotes, deploy=repo_settings.get('deploy'), )

            print(repo.get('name'), repo.get('remotes'), )
            update_info = cache.update(repo)
            print(update_info)
            for branch in update_info:
                print(branch[0], branch[2].author.name)

            #TODO do metadata parsing

            # Everything is done, closing now
    logger.debug('Shutting down gathergit..')


if __name__ == '__main__':
    exit(main())
