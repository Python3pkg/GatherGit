#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: ts=4 sw=4 et
"""gathergit

A description.

TODO:
 - do metadata parsing
"""

from time import sleep
import os
import re
import ssl
import sys
import yaml
import logging
import logging.config

# Third party libs
import argparse
import pprint
from sh import rsync
from git import Repo as _GitRepo
from git import refs as _GitRefs


def create_logger(program_name, config=None):
    if not config:
        config = {'version': 1}
    logger = logging.getLogger(program_name)
    logging.config.dictConfig(config)
    return logger


class ConfigParser(object):
    def __init__(self, confdir, config=None):
        self.confdir = confdir

        if not config:
            config = {'settings': {}, 'reposets': {}}
        self.config = config

        self.parse_directory()

    def parse_directory(self):
        for dirname, subdirectories, files in os.walk(self.confdir):
            for file_name in files:
                file_path = '{0}/{1}'.format(dirname, file_name)
                if file_name.endswith('.yaml'):
                    with open(file_path, 'r') as stream:
                        data = yaml.load(stream)
                    if data:
                        for root, value in data.items():
                            if root == 'settings':
                                self.config[root] = value
                            elif root == 'reposets':
                                for repo, settings in value.items():
                                    if repo not in self.config[root].keys():
                                        self.config[root][repo] = settings
                                    else:
                                        self.config[root][repo].update(settings)

    def dump(self):
        return self.config


class GitRepo(object):
    def __init__(self, path=None):
        self.path = path
        self.git = None

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)
            self.git = _GitRepo.init(self.path)
        else:
            self.git = _GitRepo(self.path)

    # Refs
    def update_ref(self, remote_ref, branch, remote):
        gitremote = self.get_remote(remote)
        gitref = None
        reporefs = self.get_refs()
        gitreporefs = self.get_refs(raw=True)

        srcref = '{}/{}'.format(remote, remote_ref)
        if srcref not in reporefs:
            srcref = remote_ref

        fetch_info = None
        old_commit = None
        new_commit = None

        if branch not in reporefs:
            #fetch_info = gitremote.fetch(remote_ref)
            self.git.git.checkout(srcref, b=branch)
            gitref = self.get_ref(branch)
        else:
            gitref = self.get_ref(branch)

            if str(gitref.tracking_branch()) == srcref or str(gitref.tracking_branch()).endswith('/{}'.format(srcref)):
                gitref.checkout(force=True)
            else:
                gitref.set_reference(_GitRefs.symbolic.SymbolicReference(self.git, None))
                gitref.delete(self.git, branch)
                return self.update_ref(remote_ref, branch, remote)
            old_commit = gitref.commit

        #fetch_info = gitremote.fetch(refspec='{}'.format(remote_ref))
        fetch_info = gitremote.pull(remote_ref)
        new_commit = gitref.commit
        return (fetch_info, old_commit, new_commit)

    def get_refs(self, raw=False):
        gitrefs = []
        for gitref in self.git.refs:
            if raw:
                gitrefs.append(gitref)
            else:
                gitrefs.append(str(gitref))
        return gitrefs

    def get_ref(self, name):
        refs = self.get_refs(raw=True)
        for ref in refs:
            if name == str(ref):
                return ref

    def checkout(self, branch):
        gitref = self.get_ref(branch)
        return gitref.checkout(force=True)

    # Remotes
    def add_remotes(self, remotes):
        for remote in remotes:
            if remote not in self.get_remotes():
                gitremote = self.git.create_remote(remote, remotes.get(remote).get('url'))  #TOOD
                self.git.git.config('--add', 'remote.{}.fetch'.format(remote), '+refs/tags/*:refs/tags/*')
                gitremote.fetch()

    def get_remote(self, name):
        i = 0
        for remote in self.git.remotes:
            if str(remote) == name:
                return self.git.remotes[i]
            i = i + 1

    def get_remotes(self):
        remotes = []
        for remote in self.git.remotes:
            remotes.append(str(remote))
        return remotes

    # Filesystem
    def set_path(self, path):
        self.path = path

    def get_path(self):
        return self.path


class Repo(dict):
    def __init__(self, name, remotes, deploy, gitrepo=GitRepo()):
        self['name'] = name
        self['remotes'] = remotes
        self['deploy'] = deploy
        self.git = gitrepo


class Cache(object):
    def __init__(self, settings):
        self.settings = settings
        self.path = self.settings.get('path', '/tmp/gathergit-cache')

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)

    def update(self, repo):
        remotes = repo.get('remotes')

        repo_path = '{}/{}'.format(self.path, remotes.get(list(remotes.keys())[0]).get('repo'))  #TODO
        repo.git.set_path(repo_path)
        repo.git.init()
        repo.git.add_remotes(remotes)

        changed_versions = []
        for remote_name in remotes:
            for version, version_data in repo.get('deploy').items():
                remote_ref = version_data.get('remote_ref')
                info, old_commit, new_commit = repo.git.update_ref(remote_ref, version, remote_name)
                info = info[0]
                if new_commit != old_commit:
                    changed_versions.append((repo, version, old_commit, new_commit))
        return changed_versions


class Target(object):
    def __init__(self, reposet_settings):
        self.path = reposet_settings.get('target', '/tmp/gitgather-deployment')
        self.init()

    def init(self):
        if not os.path.isdir(self.path):
            os.makedirs(self.path)

    def update(self, update_info):
        versions = {}
        version_list = None

        for update in update_info:
            repo, version, old_commit, new_commit = update
            versions[version] = {'repo': repo, 'old_commit': old_commit, 'new_commit': new_commit}

            dst_path = '{}/{}/{}/'.format(self.path, version, repo.get('name'))
            src_path = '{}/{}'.format(repo.git.get_path(), repo.get('deploy').get(version).get('root'))
            if not src_path.endswith('/'):
                src_path += '/'
            if not os.path.isdir(dst_path):
                os.makedirs(dst_path)

            repo.git.checkout(version)

            print(version, dst_path)
            print(rsync('--verbose', '--archive', '--checksum', '--delete', '--exclude=.git/', src_path, dst_path))


def main():
    version = '0.0.1'
    program_name = 'gathergit'
    parser = argparse.ArgumentParser(prog=program_name, description='A description')

    # General args
    parser.add_argument('-V', action='version', version='%(prog)s {version}'.format(version=version))
    parser.add_argument('-t', '--test',
                        action='store_true',
                        dest='test',
                        help='Run in test mode, run read-only IMAP commands only',
                        default=None)
    parser.add_argument('--confdir',
                        action='store',
                        dest='confdir',
                        help='directory to search for configuration files (default: config/)',
                        default='config/')

    parser_results = parser.parse_args()
    confdir = parser_results.confdir
    test = parser_results.test

    # Config Parsing
    cfg_parser = ConfigParser(confdir)
    config = cfg_parser.dump()
    if test is not None:
        config['settings']['test'] = test

    # Logging
    logconfig = config.get('settings', {}).get('logging', {})
    logger = create_logger(program_name, logconfig)

    # Let's start working now
    logger.debug('Starting new instance of %s', program_name)
    logger.debug('Raw configuration: %s', config)

    caches = {}
    for cacheid, cache_settings in config.get('settings').get('cache').items():
        caches[cacheid] = Cache(settings=cache_settings)

    for reposetid, reposet_settings in config.get('reposets').items():
        target = reposet_settings.get('target', None)
        cache = caches[reposet_settings.get('cache', 'common')]
        cache.init()

        for repoid, repo_settings in reposet_settings.get('repos').items():
            if repo_settings.get('deploy') is None:
                continue
            remotes = repo_settings.get('remotes', None)
            if not remotes:
                remotes = {
                    'origin': {
                        'url': repo_settings.get('url', '{}/{}'.format(reposet_settings.get('defaults').get('base_url'),
                                                                       repo_settings.get('repo'))),
                        'repo': repo_settings.get('repo'),
                    }
                }

            _deploy = repo_settings.get('deploy')
            deploy = _deploy
            for version, version_data in deploy.items():
                if isinstance(version_data, str):
                    deploy[version] = {'remote_ref': version_data}
                else:
                    schema = version_data.get('schema')

                if 'root' not in deploy[version].keys():
                    deploy[version]['root'] = ''

            repo = Repo(name=repo_settings.get('name', repoid), remotes=remotes, deploy=deploy)
            print(repo.get('name'), repo.get('remotes'))

            update_info = cache.update(repo)

            target = Target(reposet_settings)
            if update_info:
                target.update(update_info)

    # Everything is done, closing now
    logger.debug('Shutting down gathergit..')


if __name__ == '__main__':
    exit(main())
